<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Derivation Graph — Formula Inline Edit</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
  <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
  <style>
    :root {
      color-scheme: light;
    }

    body {
      margin: 0;
      background: #f8f6f1;
      color: #1e293b;
      font-family: system-ui, sans-serif;
    }

    #cy {
      height: 100vh;
      width: 100%;
      background: #faf9f6;
      position: relative;
      overflow: hidden;
    }

    .node-box {
      position: absolute;
      background: #fffdf7;
      border: 1px solid #d8d3c3;
      border-radius: 0.75rem;
      padding: 0.65rem 0.75rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      min-width: 180px;
      transform: translate(-50%, -50%);
      transition: box-shadow 120ms ease, border-color 120ms ease, outline 120ms ease;
      cursor: pointer;
    }

    .node-box.editing {
      border-color: #9b8f72;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
    }

    .node-box.focused {
      border-color: #bfa96c;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.18);
      outline: 3px solid rgba(191, 169, 108, 0.35);
    }

    .node-formula {
      font-size: 17px;
      color: #111827;
    }

    .node-editor {
      display: none;
      margin-top: 0.4rem;
    }

    .node-box.editing .node-formula {
      display: none;
    }

    .node-box.editing .node-editor {
      display: block;
    }

    textarea.inline-edit {
      width: 100%;
      min-height: 5.5rem;
      border: 1px solid #cfc7b3;
      border-radius: 0.6rem;
      padding: 0.45rem 0.55rem;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95rem;
      resize: vertical;
      background: #fefdfa;
      color: #1f2937;
      box-sizing: border-box;
    }

    textarea.inline-edit:focus {
      outline: 2px solid #bfa96c;
      outline-offset: 0;
    }

    .edit-hint {
      margin-top: 0.35rem;
      font-size: 0.75rem;
      color: #6b7280;
    }

    .edit-actions {
      margin-top: 0.45rem;
      display: flex;
      justify-content: flex-end;
      gap: 0.4rem;
    }

    .edit-actions button {
      border: 1px solid #b8a66a;
      background: #f5e9c9;
      color: #544216;
      border-radius: 0.5rem;
      padding: 0.25rem 0.8rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
    }

    .edit-actions button.cancel {
      border-color: #d1d5db;
      background: #f3f4f6;
      color: #374151;
    }

    .edit-actions button:hover {
      filter: brightness(0.97);
    }
  </style>
</head>
<body>
  <div id="cy"></div>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const store = {
      nodes: [
        { id: 'def_L', latex: 'L = T - V' },
        { id: 'eq_EL', latex: '\\frac{d}{dt}\\frac{\\partial L}{\\partial \\dot q} - \\frac{\\partial L}{\\partial q} = 0' }
      ],
      edges: [
        { id: 'e1', source: 'def_L', target: 'eq_EL' }
      ],
      activeNodeId: null
    };

    if (typeof cytoscapeDagre === 'function') {
      cytoscape.use(cytoscapeDagre);
    }

    const cy = cytoscape({
      container: document.getElementById('cy'),
      layout: { name: 'dagre', rankDir: 'TB', nodeSep: 120, rankSep: 140 },
      style: [
        {
          selector: 'node',
          style: {
            'shape': 'round-rectangle',
            'background-opacity': 0,
            'label': 'data(latex)',
            'text-opacity': 0
          }
        },
        {
          selector: 'edge',
          style: {
            'width': 2,
            'line-color': '#cbbf9d',
            'target-arrow-color': '#cbbf9d',
            'target-arrow-shape': 'triangle'
          }
        }
      ],
      elements: {
        nodes: store.nodes.map((n) => ({ data: n })),
        edges: store.edges.map((e) => ({ data: e }))
      }
    });

    const container = cy.container();
    const nodeBoxes = new Map();

    function renderLatex(target, latex) {
      try {
        target.innerHTML = katex.renderToString(latex, { throwOnError: false });
      } catch (err) {
        target.textContent = latex;
      }
    }

    function positionBox(node, box) {
      if (!box) return;
      const pos = node.renderedPosition();
      box.style.left = pos.x + 'px';
      box.style.top = pos.y + 'px';
    }

    function updatePositions() {
      cy.nodes().forEach((node) => {
        const state = nodeBoxes.get(node.id());
        if (state) {
          positionBox(node, state.wrapper);
        }
      });
    }

    function createBox(node) {
      const wrapper = document.createElement('div');
      wrapper.className = 'node-box';

      const preview = document.createElement('div');
      preview.className = 'node-formula';
      renderLatex(preview, node.data('latex'));

      const editor = document.createElement('div');
      editor.className = 'node-editor';

      const textarea = document.createElement('textarea');
      textarea.className = 'inline-edit';
      textarea.value = node.data('latex');

      const hint = document.createElement('div');
      hint.className = 'edit-hint';
      hint.textContent = 'Enter toggles edit · Ctrl/Cmd + Enter saves · Esc cancels';

      const actions = document.createElement('div');
      actions.className = 'edit-actions';

      const saveBtn = document.createElement('button');
      saveBtn.type = 'button';
      saveBtn.textContent = 'Save';

      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'cancel';

      actions.appendChild(cancelBtn);
      actions.appendChild(saveBtn);

      editor.appendChild(textarea);
      editor.appendChild(hint);
      editor.appendChild(actions);

      wrapper.appendChild(preview);
      wrapper.appendChild(editor);
      container.appendChild(wrapper);

      positionBox(node, wrapper);

      wrapper.tabIndex = -1;
      wrapper.setAttribute('role', 'group');

      const state = {
        id: node.id(),
        wrapper,
        preview,
        editor,
        textarea,
        mode: 'view',
        enterEdit,
        exitEdit,
        setFocused,
        focusWrapper
      };

      function enterEdit() {
        if (state.mode === 'edit') return;
        focusNode(node.id());
        state.mode = 'edit';
        wrapper.classList.add('editing');
        textarea.value = node.data('latex');
        setTimeout(() => {
          textarea.focus();
          textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }, 0);
      }

      function exitEdit(saveChanges, options = {}) {
        if (state.mode !== 'edit') return;
        if (saveChanges) {
          const next = textarea.value;
          node.data('latex', next);
          renderLatex(preview, next);
        } else {
          textarea.value = node.data('latex');
        }
        state.mode = 'view';
        wrapper.classList.remove('editing');
        textarea.blur();
        if (options.restoreFocus !== false) {
          focusWrapper();
        }
      }

      function setFocused(isFocused) {
        if (isFocused) {
          wrapper.classList.add('focused');
          focusWrapper();
        } else {
          wrapper.classList.remove('focused');
        }
      }

      function focusWrapper() {
        if (typeof wrapper.focus === 'function') {
          try {
            wrapper.focus({ preventScroll: true });
          } catch (err) {
            wrapper.focus();
          }
        }
      }

      wrapper.addEventListener('click', (event) => {
        event.stopPropagation();
        focusNode(node.id());
        enterEdit();
      });

      saveBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        exitEdit(true);
      });

      cancelBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        exitEdit(false);
      });

      return state;
    }

    cy.nodes().forEach((node) => {
      nodeBoxes.set(node.id(), createBox(node));
    });

    cy.on('position', 'node', (evt) => {
      const state = nodeBoxes.get(evt.target.id());
      if (state) {
        positionBox(evt.target, state.wrapper);
      }
    });

    function getActiveState() {
      return nodeBoxes.get(store.activeNodeId) || null;
    }

    function focusNode(id, options = {}) {
      if (!id) {
        if (store.activeNodeId) {
          const previous = nodeBoxes.get(store.activeNodeId);
          if (previous) {
            if (previous.mode === 'edit') {
              previous.exitEdit(options.saveOnBlur !== false, { restoreFocus: false });
            }
            previous.setFocused(false);
          }
          store.activeNodeId = null;
        }
        return;
      }

      const target = nodeBoxes.get(id);
      if (!target) return;

      if (store.activeNodeId && store.activeNodeId !== id) {
        const previous = nodeBoxes.get(store.activeNodeId);
        if (previous) {
          if (previous.mode === 'edit') {
            previous.exitEdit(options.saveOnBlur === false ? false : true, { restoreFocus: false });
          }
          previous.setFocused(false);
        }
      }

      store.activeNodeId = id;
      target.setFocused(true);
    }

    function focusByIndex(index) {
      if (!store.nodes.length) return;
      const normalized = (index + store.nodes.length) % store.nodes.length;
      const nodeId = store.nodes[normalized].id;
      focusNode(nodeId);
    }

    function focusNextNode() {
      if (!store.nodes.length) return;
      if (!store.activeNodeId) {
        focusNode(store.nodes[0].id);
        return;
      }
      const currentIndex = store.nodes.findIndex((n) => n.id === store.activeNodeId);
      focusByIndex(currentIndex + 1);
    }

    function focusPreviousNode() {
      if (!store.nodes.length) return;
      if (!store.activeNodeId) {
        focusNode(store.nodes[store.nodes.length - 1].id);
        return;
      }
      const currentIndex = store.nodes.findIndex((n) => n.id === store.activeNodeId);
      focusByIndex(currentIndex - 1);
    }

    function focusFirstNode() {
      if (!store.nodes.length) return;
      focusNode(store.nodes[0].id);
    }

    function focusLastNode() {
      if (!store.nodes.length) return;
      focusNode(store.nodes[store.nodes.length - 1].id);
    }

    function handleNavigation(key, event) {
      if (key === 'Home') {
        focusFirstNode();
        return;
      }
      if (key === 'End') {
        focusLastNode();
        return;
      }
      if (key === 'Tab') {
        if (event.shiftKey) {
          focusPreviousNode();
        } else {
          focusNextNode();
        }
        return;
      }
      if (key === 'ArrowUp' || key === 'ArrowLeft') {
        focusPreviousNode();
        return;
      }
      if (key === 'ArrowDown' || key === 'ArrowRight') {
        focusNextNode();
      }
    }

    function handleGlobalKeydown(event) {
      const activeState = getActiveState();
      if (!activeState) return;

      const key = event.key;
      const isNavigationKey = key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight' || key === 'Home' || key === 'End' || key === 'Tab';

      if (activeState.mode === 'edit') {
        if (key === 'Escape') {
          event.preventDefault();
          activeState.exitEdit(false);
          return;
        }
        if (key === 'Enter' && (event.metaKey || event.ctrlKey)) {
          event.preventDefault();
          activeState.exitEdit(true);
          return;
        }
        if (key === 'Enter' && !event.shiftKey && !event.altKey && !event.metaKey && !event.ctrlKey) {
          event.preventDefault();
          activeState.exitEdit(true);
          return;
        }
        if (isNavigationKey) {
          event.preventDefault();
          activeState.exitEdit(true);
          handleNavigation(key, event);
        }
        return;
      }

      if (key === 'Enter' && !event.shiftKey && !event.altKey && !event.metaKey && !event.ctrlKey) {
        event.preventDefault();
        activeState.enterEdit();
        return;
      }

      if (isNavigationKey) {
        event.preventDefault();
        handleNavigation(key, event);
      }
    }

    store.focusNode = focusNode;
    store.focusNextNode = focusNextNode;
    store.focusPreviousNode = focusPreviousNode;
    store.focusFirstNode = focusFirstNode;
    store.focusLastNode = focusLastNode;

    document.addEventListener('keydown', handleGlobalKeydown);

    cy.on('pan zoom', updatePositions);
    cy.on('render', updatePositions);
    window.addEventListener('resize', updatePositions);
    cy.on('tap', 'node', (evt) => {
      focusNode(evt.target.id());
    });

    focusFirstNode();
  });
  </script>
</body>
</html>
